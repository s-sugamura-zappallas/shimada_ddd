以下に、現時点での要件・方針に基づき、DDDを念頭に置いた**仕様書ドラフト**をまとめます。  
- **目的**: 今後の拡張（他の占い師への対応、データ永続化など）を見越して、APIおよびシステム全体を整理し、ドキュメント化する。  
- **内容**: 
  1. **全体概要**  
  2. **ユースケース一覧・フロー**  
  3. **ドメインモデル(概念図/クラス図)**  
  4. **データフロー図(DFD)**  
  5. **コンテキストマップ**  
  6. **ディレクトリ構成例**  

必要に応じて、これらのドキュメントを発展させながら運用していく想定です。  

---
# 1. 全体概要

## 1.1. システムの目的

- **Chapli**などのフロントアプリが撮影/解析した"手相情報"と、ユーザーからの質問回答(QA)をまとめてAPIに送信し、特定の「占い師」(初期は島田周平さん風)の口調・ルールでLLMを用いて鑑定結果メッセージを生成する。  
- 生成結果は**ステートレス**に返却する想定だが、将来的にユーザーの過去やり取りや好みを考慮できるよう、**永続化**する拡張性を残す。  
- LLMとしてはBedrock/Geminiなど複数を用意し、フォールバックや切り替えが可能なアーキテクチャとする。  

## 1.2. 主な特徴・要件

1. **手相鑑定専用**: ドメインはあくまで「手相鑑定」であり、他の占い手法（タロット等）は想定しない。  
2. **複数占い師対応**: エンドポイントを増やしていく形で、将来的に「島田周平さん風」→「他の占い師さん風」に拡張可能。  
3. **ステートレス**: 初期実装ではデータ保存なし。しかし将来的に、ユーザープロファイルや過去回答履歴などを参照し、よりパーソナライズされた鑑定が可能になる。  
4. **認証**: AWS Cognito による認証トークンを用い、クライアントID/Secret単位でクライアント(Chapliなど)を増やす方針。  
5. **LLM連携**: 外部LLM(Bedrock, Gemini...)が応答しない/遅い際にはフォールバックを行うなど、レートリミットや障害対策を考慮。  
6. **拡張性**: 将来的にデータベースへの保存や、LLMの切り替えロジック、レートリミット戦略などを実装しやすいよう、DDDベースのモジュール分割を行う。  

---
# 2. ユースケース一覧・フロー

## 2.1. ユースケース概要

大きく分けて以下の2種類がある想定です（現時点）:

1. **シングル分析 (Single Analysis)**  
   - ユーザー1名の手相情報(analysisLines)とQ&A内容をもとに鑑定。  
2. **ペア分析 (Pair Analysis)**  
   - ユーザー2名の手相情報(analysisLinesPerson1, analysisLinesPerson2, compatibilityTexts)とQ&A内容をもとに鑑定。

いずれも**固定シナリオのQnA**(例: 「今一番悩んでいること」「過去に頑張ったこと」など)と、直近のユーザー入力(messages)を組み合わせてLLMを呼び出し、  
島田さん風のトーンでメッセージを生成して返す。

## 2.2. 典型的なシステムフロー

1. **ユーザー(フロント)**  
   - Chapliなどのフロントアプリからログイン(Cognito)。  
   - 手相写真を撮影し、別API(手相解析サービス)に送る。  
   - 解析サービスから得た手相情報(線の種類や特徴)を受け取り、フロントで質問(QA)に回答する。  

2. **本API(今回設計対象)**  
   1. フロントが**手相情報 + QA回答 + 会話履歴(messages)**をPOSTする。  
   2. バリデーション(Zod)で入力形式チェック。  
   3. サーバサイドで**systemPrompt**に、島田さん風トーン・ルールを合成し、外部LLMにリクエストする。  
      - (1) Bedrockに送る  
      - (2) 失敗orタイムアウトの場合Geminiにフォールバック  
   4. LLMからの応答をまとめてレスポンス(JSON)として返却。  

3. **フロント**  
   - 得られた鑑定結果をチャットUIに表示。  
   - 必要に応じて再度Q&Aや追加のやり取りを行う(が、それらは基本的にフロント側のシナリオ制御)。  

---
# 3. ドメインモデル(概念図/クラス図)

本システムでは、将来的な拡張（ユーザー情報の永続化、好み/履歴による出力制御など）を見据え、DDDのレイヤーを意識します。

## 3.1. 主なドメインオブジェクト例

1. **PalmReadingAnalysis**(集約ルート候補)  
   - 手相情報(単数/ペア)や質問回答、鑑定結果などをひとまとまりに扱う際の概念。  
   - ステートレスならAPI Request/Responseレベルで扱うが、将来的に永続化する可能性がある。  

2. **FortuneTeller**(Value Object or Service)  
   - 「島田さん風」「他の占い師風」など、スタイルを切り替える際に使う。  
   - 内部的にsystemPromptなどを持つことも考えられる。  

3. **LLMService**(ドメインサービス or インフラサービス)  
   - BedrockやGeminiとやり取りし、プロンプト生成 → 結果取得までを担う。  
   - 複数実装(Strategyパターンなど)を切り替えられるようにする。  

4. **User**(将来的にエンティティ)  
   - Cognitoで管理されるが、システム上は「ユーザーID」「年齢」「性別」などを保持し、過去分析履歴を参照する可能性がある。  

## 3.2. 簡易クラス図(サンプル)

docs/diagrams/domain-class-diagram.mmd を参照

- **PalmReadingAnalysis** が分析(シングル or ペア)の単位を表す。  
- **LLMService** インターフェースを実装する形で**BedrockService**, **GeminiService**を用意。  
- **FortuneTeller** は島田さんや他の占い師の「口調・システムプロンプト生成ロジック」を持つイメージ。  

---
# 4. データフロー図(DFD)

ここでは**入力/出力(I/O)**が分かる粒度で示します。  

docs/diagrams/data-flow.mmd を参照

1. フロントから **`POST /llm/shimada/chat`**  
2. **Zod** でバリデーションが通ればアプリケーション層へ。  
3. palmReadingAnalysis等のドメインオブジェクトを組み立て、**FortuneTeller**(島田さん風)のスタイルガイドを反映したsystemPromptを生成。  
4. LLMService(Bedrock)へリクエスト → 成功なら返却。失敗/タイムアウトならGeminiへフォールバック。  
5. 最終的な応答をまとめて**JSON**でフロントに返却。  

---
# 5. コンテキストマップ

docs/diagrams/context-map.mmd を参照

- **PalmReading Context**が中心で、Auth Context(Cognito)から認証情報を受け、LLM Integration Context(Bedrock/Gemini)に処理を依頼する構成。

---
# 6. ディレクトリ構成例

docs/architecture.md を参照



---

## 今後の拡張ポイント

1. **他占い師への対応**  
   - `domain/services/FortuneTeller.ts`を拡張し、「OkushiFortuneTeller」など別実装を追加し、`/llm/okushi/chat`等エンドポイントを追加。  
2. **永続化**  
   - `domain/repositories` で `PalmReadingAnalysisRepository` や `UserRepository` を定義、 `infrastructure/db` で実装し、ユーザー履歴などを保存。  
3. **複数LLM連携・フォールバックロジック**  
   - `application/services/LLMOrchestrator.ts`で各LLM実装(Bedrock/Gemini)を並列で呼ぶ/順次フォールバックするなどの拡張。  
4. **レートリミット**  
   - `infrastructure/http` や `application/services` でリミット超過時の再試行や別LLMへの振り分けを実装。  

--- 